# 需求分析

需求：统计出[目标以太坊地址](https://etherscan.io/address/0xae2fc483527b8ef99eb5d9b44875f005ba1fae13)从区块高度19800000开始到19816000的交互过的`uniswapV2`交易对（名称/地址），以及该地址在每个交易对上的盈利（按交易对累计)。编程语言不限，只需要输出结果，不需要考虑数据存储问题。

需求分析：

- 根据用户的地址可以在区块中过滤出该用户所有的转账记录，我想到的方式是扫描每一个区块，过滤`form`和`to`为用户地址的交易，将其过滤出来；如果可以第三方的信任机构，使用以太坊浏览器进行
- 根据用户的交易记录，可以获取到非用户地址的地址，需要判断该地址是否是`Uniswap V2` 的 `Pair`，也就是在 `UniswapV2Factory` 合约中是否存在，但是`UniswapV2Factory`合约没有判断一个合约地址是否存在的地址，只有一个方法：由两个代币地址得出`Pair`地址，结果为0就说明不存在；这个方法不能满足想要的结果；我的设计是根据`UniswapV2Factory`的`allPairs`的数组和`allPairsLength`方法，将所有`pair`的地址都获取到存储到本地，用一个`Set`数据结构存储，粗略估计了一下大小：每个地址大小：`32 Byte`，目前2024.05.08，大概有`320000`个`pair`，总存储约`10MB`左右，所以放到`Redis`中就可以；用`Set`数据结构中判断是否包含`ERC-20`地址，若包含则是`Uniswap V2` 的 `Pair`，即用户与该交易对交易过；
- 需求中需要获取交易对的名称和地址，交易对的地址已经存在，如何获取名称，查看交易对地址`name`为`Uniswap V2`，`symbol`为`UNI-V2`，并不具有可读性和解释性，所以需要分别获取`pair`合约中的`token0`和`token1`的`ERC-20`地址，然后获取其`symbol`，为了优化性能，可以将该地址的`symbol`进行缓存，用`Map<tocken address,symbol>`数据结构进行存储；
- 获取该地址在每个交易对上的盈利，每次用户进行`swap`操作的时候，相当于： `x` 个 `token0` ➡`pair`➡ `y` 个`token1`，所以只需要计算该地址在每个`pair`的交易过所有代币交易即可，初始值是0，若是从该地址转出就减去转出的数量，若是转入该地址就加上转入的数量，用`Map<pair address,Map<token address,value>>`数据结构进行存储；
- 我对题目的描述的理解是不包含该地址向合约地址进行质押的情况，用户盈利只包含`swap`，所以没有包含设计质押盈利的分析。

