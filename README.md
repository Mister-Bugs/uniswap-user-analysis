# 需求分析

需求：统计出[目标以太坊地址](https://etherscan.io/address/0xae2fc483527b8ef99eb5d9b44875f005ba1fae13)从区块高度19800000开始到19816000的交互过的`uniswapV2`交易对（名称/地址），以及用户地址在每个交易对上的盈利（按交易对累计)。编程语言不限，只需要输出结果，不需要考虑数据存储问题。

需求分析：

- 根据用户的地址可以在区块中过滤出该用户所有的转账记录，我想到的方式是扫描每一个区块，过滤`form`和`to`为用户地址的交易，根据用户地址过滤出来；如果可以第三方的信任机构，使用以太坊浏览器进行
- 根据用户的交易记录，可以获取到非用户地址的地址，需要判断用户地址是否是`Uniswap V2` 的 `Pair`，也就是在 `UniswapV2Factory` 合约中是否存在，但是`UniswapV2Factory`合约没有判断一个合约地址是否存在的地址，只有一个方法：由两个代币地址得出`Pair`地址，结果为0就说明不存在；这个方法不能满足想要的结果；我的设计是根据`UniswapV2Factory`的`allPairs`和`allPairsLength`方法，将所有`pair`的地址都获取到存储到本地，用一个`Set`数据结构存储，粗略估计了一下大小：每个地址大小：`32 Byte`，目前2024.05.08，大概有`320000`个`pair`，总存储约`10MB`左右，所以放到`Redis`中就可以；用`Set`数据结构中判断是否包含`ERC-20`地址，若包含则是`Uniswap V2` 的 `Pair`，即用户与该交易对交易过；
- 需求中需要获取交易对的名称和地址，交易对的地址已经存在，如何获取名称，查看交易对地址`name`为`Uniswap V2`，`symbol`为`UNI-V2`，并不具有可读性和解释性，所以需要分别获取`pair`合约中的`token0`和`token1`的`ERC-20`地址，然后获取其`symbol`，为了优化性能，可以将用户地址的`symbol`进行缓存，用`Map<tocken address,symbol>`数据结构进行存储；
- 获取用户地址在每个交易对上的盈利，每次用户进行`swap`操作的时候，相当于： `x` 个 `token0` ➡`pair`➡ `y` 个`token1`，所以只需要计算用户地址在每个`pair`的交易过所有代币交易即可，初始值是0，若是从用户地址转出就减去转出的数量，若是转入用户地址就加上转入的数量，用`Map<pair address,Map<token address,value>>`数据结构进行存储。

# 方案设计

1. 以太坊节点，因为我没有搭建以太坊节点，所以我采用的是第三方提供的节点，一开始使用`infura`，但是我的`vpn`无法访问到，最终采用`quiknode`实现，使用第三方节点的缺点就是访问受限，免费版查询功能一次查询的区块范围最大为5个，并且每天有限次；
2. 使用`node.js`开发，使用`ethers.js`库，首先连接以太坊网络；
3. 根据工厂合约地址、`ABI`、以太坊节点创建合约工厂实例，根据`allPairs`和`allPairsLength`方法获取所有的`pair`地址缓存到本地`Set<address>`；
4. 使用第三方数据`Etherscan`，获取用户所有的交易数据，可以获取后再验证，针对每一条交易，判断`from`和`to`是否是非用户节点，如果是非用户地址，则判断`Set`中是否存在，若存在则说明是`pair`合约地址；
5. 若果是`pair`合约，需要根据其`token0`和`token1`的`symbol`拼接为合约名称，先去`Map<tocken address,symbol>`判断是否存在，若没有，根据`pair`合约地址、`ABI`、以太坊节点创建`pair`合约实例，获取`token0`和`token1`的地址，然后再创建实例，获取`symbol`，合成名称，再放入`Map<tocken address,symbol>`中；
6. 计算用户地址在每个交易对上的盈利，计算用户地址在每个`pair`的交易过所有代币交易即可，针对每一笔与`pair`合约进行的交易，将每一笔交易的盈利情况存储到`Map<pair address,Map<token address,value>>`，最终遍历`Map`，计算每一个代币的盈利情况，存储到`Map<token address,value>`最终输出到本地文件中。

# 优化

- 建立本地节点，根据链上数据构建高性能的本地数据库；
- 使用并行思想优化，可以同时获取多个区块的数据以及并行处理每个区块中的交易数据；
